[{"content":"","permalink":"https://dnjp.github.io/pages/c/","summary":"","title":"C"},{"content":"Debugging Under Fire: Keep your Head when Systems have Lost their Mind - Bryan Cantrill\nWhen a Microsecond Is an Eternity: High Performance Trading Systems in C++ - Carl Cook\nBeating the Averages - Paul Graham\nGo Proverbs - Rob Pike\nThe Ubiquitous File Server in Plan 9 - C H Forsyth (2005)\nThe Styx Architecture for Distributed Systems - Rob Pike\nPlan 9 - Rob Pike, Dave Presotto, Sean Dorward, Bob Flandrena, Ken Thompson, Howard Trickey, Phil Winterbottom\nNotes On Programming In C - Rob Pike\nRc The Plan 9 Shell - Tom Duff\nWriting a 9P server from scratch\ncomp.lang.c Frequently Asked Questions\nvi command help guide - Jeff W.\nThe Illumos Dynamic Tracing Guide\nSed\n","permalink":"https://dnjp.github.io/pages/favorite-links-papers/","summary":"Debugging Under Fire: Keep your Head when Systems have Lost their Mind - Bryan Cantrill\nWhen a Microsecond Is an Eternity: High Performance Trading Systems in C++ - Carl Cook\nBeating the Averages - Paul Graham\nGo Proverbs - Rob Pike\nThe Ubiquitous File Server in Plan 9 - C H Forsyth (2005)\nThe Styx Architecture for Distributed Systems - Rob Pike\nPlan 9 - Rob Pike, Dave Presotto, Sean Dorward, Bob Flandrena, Ken Thompson, Howard Trickey, Phil Winterbottom","title":"Favorite Links \u0026 Papers"},{"content":"The goal of Plan 9 was to build a system that was centrally administered and cost-effective using cheap modern microcomputers as its computing elements. The idea was to build a time-sharing system using different computers that handle different tasks. Small machines in your office would serve as terminals to large, central, shared resources such as computing servers and file servers.\nPlan 9 is highly influenced by the Cambridge Distributed System. The early catch phrase was to build a UNIX out of a lot of little systems, not a system out of a lot of little UNIXes.\nPlan 9 adopted the idea of using the file system to manage resources but instead uses a network-level protocol (9P) to enable machines to access files on remote systems.\nUses naming system that allows for customized views of the resources in the network\nAllows the user to build a private computing environment and recreates it wherever desired instead of on their private machine\nPer-process name spaces and file-system like resources are used extensively throughout the system\nThere is no \u0026rsquo;tty driver\u0026rsquo; in the kernel - that job is given to the window system\nDesign\nThe view of the system is built on three principles\nResources are named and accessed like files in a hierarchical file system\nThere is a standard protocol (9P) for accessing these resources\nThe disjoint hierarchies provided by different services are joined together into a single private hierarchical file name space\nThis provides the following benefits:\nThe terminal is temporarily personalized by that user\nInstead of customizing hardware, you can customize one\u0026rsquo;s view of the system provided by the software\nPersonalization is accomplished by giving local, personal names for the publicly visible resources in the network\nFor example /dev/cons always refers to the user\u0026rsquo;s terminal and /bin/date the correct version of the date command to run, but which files those names represent depends on circumstances such as the architecture of the machine executing date.\n9P is structures as a set of transactions that send a request from a client to a server and return the result. You can control file systems as well as files with 9P. File access is at the level of bytes, not blocks, which distinguishes 9P from NFS or RFS. A Comparison of Three Distributed File System Architectures: Vnode, Sprite, and Plan 9 provides a deeper look into these differences.\nCommand-level View\nEach window created by a user is run a separate name space. Changes in one name space do not affect other windows or programs. Each window has a private bitmap and mulpiplexed access to the keyboard, mouse, and other resources through /dev/mouse, /dev/bitblt, and /dev/cons (analogous to /dev/tty in unix). Unlike in X, a remote rio application sees the mouse, bitblt, and cons files for windows as usual in /dev. It does not know whether the files are local - it just reads/writes to control The File Server\nA central file server stores permanent fies and presents them to the network as a file hierarchy exported using 9P. The server is a stand-alone system, accessible over the network, and designed to do its one job well. No user processes are run, only a fixed set of routines compiled into the boot image. The main hierarchy exported by the server is a single tree, representing files on many disks. That hieararchy is shared by users over the network.\nWORM - write-once-read-many\nThe filesystem disk is a cache for the WORM and memory is a cache for the disk. Every morning at 5am, a dump of the file system occurs automatically. The file system is frozen and all blocks modified since the last dump are queued to be written to the WORM. Once the blocks are queued, service is restored and the read-only root of the dumped file system appears in a hierarchy of all dumps ever taken, named by its date. i.e. the directory /n/dump/1995/0315 is the root directory of an image of the file system as it appeared on 3/15/1995. This means that restoring a file is as simple as copying over the version from the dump you\u0026rsquo;re interested in. Backup problems can then be solved with standard tools like cp, ls, grep, and diff. The dump file system is read-only the permissions cannot be changed. Once a file is written to WORM, it cannot be removed.\nUnusual File Servers\nRio provides two interfaces. To the user, they are presented a familiar style of interaction with the keyboard and mouse. To client programs, they are presented a set of files in /dev to read/write to.\nWrite to /dev/cons to print text to the window\nTo read the mouse, they read /dev/mouse\nBitmap graphics are implemented by reading/writing encoded messages to /dev/bitblt\nRio is a file server, serving the files in /dev to clients. Each client is given a private nam space with a different set of files in /dev to work on. Local name spaces make this possible.\nBecause Rio is implemented as a file server, it can postpone answering read requests for a particular window which is toggled using a reserved key on the keyboard (escape). In 9term, press Esc to turn off reads. This enables you to write as many lines as desired without them being evaluated. When finished, press Esc again and the commands will be evaluated line by line.\nThere is no ftp command in Plan 9 - instead a file server called ftpfs dials the ftp site, logs in, and uses the ftp protocol to examine files in the remote directory. It essentially translates the FTP protocol into 9P to offer Plan 9 access to ftp sites.\nexportfs is a user process that takes a portion of its own name space and makes it available to other processes by translating 9P requests into system calls to the Plan 9 kernel. It is usually run as a remote server started by a local program, either import or cpu. Import calls the remote machine, starts exportfs, and attaches its 9P connection to the local name space.\nConfigurability and administration\nCentral file servers centralize not just the files, but also their administration and maintenance. One server is the main server, holding all system files, other servers provide extra storage or are available for debugging and other special uses, but the system software resides on one machine. This means that each program has a single copy of the binary for each architecture, so it is trivial to install updates and bug fixes. There is also a ringle user database; there is no need to syncrhonize distinct /etc/passwd files.\nOn the central server there is a directory /lib/ndb that contains all the information necessary to administer networks. All the machines use the same database to talk to the network. To install a new machine on the local Ethernet, choose a name and IP addres and add these to a single file in /lib/ndb. All the machines in the installation will be able to talk to it immediately. To start running, plug the machine into the network, turn it on, and use BOOTP and TFTP to load the kernel.\nC Programming\nPrograms in Plan 9 are generally written in rc, alef, or a dialect of ANSI C. The Plan 9 C dialect has some minor extensions and a few major restrictions. The most important restriction is that the compiler demands that all function definitions have ANSI prototypes and all function calls appear in the scope of a prototyped declaration of the function. Each system library has an associated header file, declaring all functions in that library. The standard Plan 9 library is called libc, so all C source files include \u0026lt;libc.h\u0026gt;. These rules guarantee that all functions are called with arguments having the expected types.\nAnother restriction is that the C compilers accept only a subset of the preprocessor directives. The main omission is #if. Conditional compiliation, even with #ifdef, is used sparingly in Plan 9 - only present in low-level routines in the graphics library.\nInstead of UNIX\u0026rsquo;s creat, Plan 9 has a create function that takes three arguments:\nint create(char *file, int omode, ulong perm) + `perm` defines whether the returned file descriptor is to be opened for reading, writing, or both. Plan 9 uses a 16-bit character called Unicode. To simplify the exchange of text between programs, the characters are packed into a byte stream by the UTF-8 encoding.\nAPE (ANSI C/POSIX Environment) comprises separate include files, libraries, and commands, conforming as much as possible to the strict ANSI C and base-level POSIX specifications.\n","permalink":"https://dnjp.github.io/pages/plan-9/","summary":"The goal of Plan 9 was to build a system that was centrally administered and cost-effective using cheap modern microcomputers as its computing elements. The idea was to build a time-sharing system using different computers that handle different tasks. Small machines in your office would serve as terminals to large, central, shared resources such as computing servers and file servers.\nPlan 9 is highly influenced by the Cambridge Distributed System. The early catch phrase was to build a UNIX out of a lot of little systems, not a system out of a lot of little UNIXes.","title":"Plan 9"},{"content":"This guide assumes you are running a x86-64 Linux machine and that you have an up to date version of Qemu and curl installed. You may want to clone the repo containing useful scripts to help you get started.\nIn the shell examples below, any snippet starting with $: means that it should be executed on your Linux machine. Any snippet starting with %: should be executed in the Plan 9 VM.\nInstallation\nThe run script script can setup 9front, 9front-ANTS, or the 9legacy distribution. Execute the install script and answer the prompts to install your selected distibution:\n$: ./run.sh Stick with the default options up until Plan 9 boots up. When asked what input device you would like to use, enter ps2intellimouse. You are now ready to install Plan 9. To do so, follow the install guide from the 9front FQA.\nWhen the installation is complete and you are kicked back out to the tty, shutdown the Qemu machine. Now you can simply execute the run script and select \u0026ldquo;run\u0026rdquo; to boot up your selected image.\nSetting Resolution\nObtain a list of vesa bios modes\n%: @{rfork n; aux/realemu; aux/vga -p} Configure one of the valid modes\n%: @{rfork n; aux/realemu; aux/vga -m vesa -l 1024x768x16} You will likely want to persist this setting so that it is the same when you reboot the VM. To do that, modify the vgasize option in the plan9.ini file.\nModifying plan9.ini\nBind the local hard drive kernel device over /dev\n%: bind -b '#S' /dev Specify the full path to the corresponding 9fat\n%: 9fs 9fat /dev/\u0026lt;your hd\u0026gt;/9fat Edit the file /n/9fat/plan9.ini to configure your desired boot settings. If the above does not work on your system, give this script a try.\nCreate your own user\n\u0026ldquo;glenda\u0026rdquo; is the default user on Plan 9. However, you will likely want to create a user for yourself. To do so, we will first connect to the Fossil file server console and create the new user:\n%: con -l /srv/fscons Once connected, your prompt will change to simply \u0026ldquo;prompt: \u0026ldquo;. First, create your user:\nprompt: uname \u0026lt;username\u0026gt; \u0026lt;username\u0026gt; Then you can add your user to the groups that make sense. To give your user system privileges, add yourself to the sys group:\nprompt: uname \u0026lt;username\u0026gt; +sys\nprompt: uname sys +\u0026lt;username\u0026gt;\nIf you want access to /adm then add your user to the adm group:\nprompt: uname adm +\u0026lt;username\u0026gt; Type CTL+\\ and then type q at the prompt\nNow that the file system knows about our new user, we need to configure and enable the new user. First we\u0026rsquo;ll start keyfs so we can change authentication information:\n%: auth/keyfs Then we will configure the user:\n%: auth/changeuser \u0026lt;username\u0026gt; All that\u0026rsquo;s left is to enable the user:\n%: auth/enable \u0026lt;username\u0026gt; If the above fails, make sure that the auth/cpu kernel is running in your plan9.ini. To be sure, set server=cpu in the plan9.ini.\nSetup Timezone\nThe available timezones are simply files in /adm/timezone. To select a timezone, copy your selection to /adm/timezone/local:\n%: cp /adm/timezone/\u0026lt;your selection\u0026gt; /adm/timezone/local Then open up /rc/bin/termrc in sam or acme and change the TIMESYNCARGS:\nTIMESYNCARGS=(-n pool.ntp.org) Then restart your system with fshalt -r.\nSetup keyboard\nIf you use a fairly standard layout, you\u0026rsquo;re desired settings can most easily be changed with kbmap:\n%: kbmap Right click your desired setting and then type \u0026ldquo;q\u0026rdquo; to quit. If you\u0026rsquo;re using a layout like Colemak (yours truly), then you can add the layout I have here to kbmap:\n%: hget \\ https://raw.githubusercontent.com/dnjp/plan9-on-qemu/master/extra/colemak \\ \u0026gt; /sys/lib/kbmap/colemak Then just run kbmap as above and select \u0026ldquo;colemak\u0026rdquo;. To persist these settings add something like the following to your $home/lib/profile directly above rio in the terminal case statement:\ncat /sys/lib/kbmap/colemak \u0026gt; /dev/kbmap Configure Rio\nOpen up your $home/lib/profile with either sam or acme\n%: sam $home/lib/profile If you\u0026rsquo;re using sam, you will right click on the blue bar at the top and select the file you want to edit and then right click on the pale yellow buffer below it to bring that file into focus.\nFind the line that starts the rio window manager and add the -s option. The original will look something like this:\nrio -i riostart To make rio autoscroll, add the -s option. If you\u0026rsquo;d prefer a black background, you can add the -b option. With both applied, the new command should look like this:\nrio -b -s -i riostart If $home/bin/rc/riostart does not exist, create a mostly empty script that looks like this for now:\n#!/bin/rc Then make it executable with chmod +x $home/bin/rc/riostart. To automatically start DHCP when rio starts, add this line above the switch statement:\nip/ipconfig You might want to change the default font as well. The best way to do that is to play around with the system fonts in acme. First, launch acme:\n%: acme To get a feel for how to use acme, I\u0026rsquo;d recommend watching the intro by Russ Cox. Once familiar with how to use acme, open the directory /lib/font/bit/ and try changing the font by executing something like the following in an acme buffer:\nFont /lib/font/bit/terminus/unicode.14.font Once you\u0026rsquo;ve found one you\u0026rsquo;ve liked, update your font selection in $home/lib/profile. When you are finished editing your profile, click on the blue bar to bring it into focus and enter w to write the file followed by q to quit, like this:\nw q When rio starts up you will see it has two windows open - one in the upper left showing system stats and a terminal window. The terminal window is a bit small for my taste, so let\u0026rsquo;s make it bigger.\nOpen up $home/bin/rc/riostart with sam:\n%: sam $home/bin/rc/riostart Open up the the file in your editors buffer. You will see that there are two lines starting with window. The first sets the location and size for the stats window. The second is the location and size of our initial terminal window. This is the line we want to edit.\nReplace the contents of the second window line with the following:\nwindow 200,200,850,600 Save and exit sam as you did before. Reboot the VM with the fshalt command:\n%: fshalt -r Ports\nThere are ports of some unix tools and other applications that run on Plan 9 in the 9front ports. All you have to do is clone the ports tree into your system:\n% hg clone http://code.9front.org/hg/ports /sys/ports Then to install a port, for example media-fonts, you would do this:\n%: cd /sys/ports/media-fonts %: mk nuke %: mk build %: mkdir /lib/font/ttf %: mk install Setup Git\ngit9 is a git implementation for Plan 9 by Ori Bernstein (oridb) that works quite well on Plan 9. There are two ways to install git9 - using 9front Ports or via git for the most up to date changes.\nUsing 9front Ports, the installation is very straight forward:\n%: cd /sys/ports/dev-vcs/git9 %: mk install For the git install, we\u0026rsquo;ll first get a bootstrap version which will give us the git command and then we will setup the git9 repository in a place that you can easily update it in the future.\nGet the bootstrap version:\n%: cd /tmp %: hget https://github.com/oridb/git9/archive/master.tar.gz | tar xvz %: cd git9-master %: mk all %: mk install Now we\u0026rsquo;ll get the version from git which you can easily update:\n%: cd $home/src %: git/clone https://github.com/oridb/git9 %: cd git9 %: mk all %: mk install At this point, you should have a quick read of the man page for git and gitfs that come with git9:\n%: man 1 git %: man 4 gitfs Once you\u0026rsquo;re familiarized with how git on Plan 9 works, let\u0026rsquo;s get your git config setup:\n%: mkdir -p $home/lib/git %: touch $home/lib/git/config %: sam $home/lib/git/config Add the following contents using your own information using tabs for indentation:\n[user] name = Your Name email = yourname@address.com The last part of this process is to setup your ssh keys with your git provider. First we\u0026rsquo;ll generate the public and private keys:\n%: mkdir $home/lib/ssh %: auth/rsagen -t \u0026#39;service=ssh\u0026#39; \u0026gt; $home/lib/ssh/key %: auth/rsa2ssh $home/lib/ssh/key \u0026gt; $home/lib/ssh/key.pub Now that the keys exist, we need to add them to factotum so that you can authenticate using those keys:\n%: cat $home/lib/ssh/key \u0026gt;/mnt/factotum/ctl %: ssh git@github.com %: ssh git@git.sr.ht You should get a success message saying that you have authenticated to Github in this case. You may also get an error message saying that Github does not provide shell access which is to be expected.\nAssuming that was successful, add both of those commands to $home/lib/profile so that you will be automatically authenticated. The man pages for git9 should give you most of the information that you need. The only other thing you may need to know is how to push to a repository using git+ssh instead of https. You can do that with a command like this:\n%: git/push -u git+ssh://git@github.com/youruser/yourrepo For Sourcehut, you\u0026rsquo;ll need to use ssh/git+ssh for read/write:\n%: git/clone ssh://git@git.sr.ht/~youruser/yourrepo %: git/clone git+ssh://git@git.sr.ht:~youruser/yourrepo An example configuration might look like this:\n[remote \u0026#34;origin\u0026#34;] url = git+ssh://git@git.sr.ht:~youruser/yourrepo fetch = +refs/heads/*:refs/remotes/origin/* Install Go\nYou will probably want to write programs in a language other than C while you\u0026rsquo;re working on Plan 9. Go is a popular option and many programs for Plan 9 are written in Go.\nTo install Go we will have to bootstrap the installation with an earlier version of Go already compiled for Plan 9. The process consists of obtaining the bootstap version and the target version, and telling the target version to use the bootstrapped version in order to build the toolchain.\nTo get started we will first make the directory to temporarily house the installation:\n%: ramfs %: cd /tmp Then we\u0026rsquo;ll download both the bootstrap and target versions of Go:\n%: hget http://www.9legacy.org/download/go/go1.14.1-plan9-amd64-bootstrap.tbz | bunzip2 -c | tar x %: hget https://golang.org/dl/go1.14.7.src.tar.gz | gunzip -c | tar x Now we\u0026rsquo;ll make the directory which will contain our target installation and bind the version we downloaded to that target directory:\n%: mkdir -p /sys/lib/go/amd64-1.14.7 # bind downloaded go source to system go source %: bind -c go /sys/lib/go/amd64-1.14.7 In order to ensure that the GOROOT is set correctly, we will change to the target directory when building Go and tell it where to locate our bootstrap installation:\n%: cd /sys/lib/go/amd64-1.14.7/src %: GOROOT_BOOTSTRAP=/tmp/go-plan9-amd64-bootstrap Next, configure loopback addresses so that the standard library tests will pass:\n%: ip/ipconfig -P loopback /dev/null 127.1 %: ip/ipconfig -P loopback /dev/null ::1 Now that we have everything in place, it\u0026rsquo;s time to start the install. Now\u0026rsquo;s the time to go get some lunch or do something else because it will take quite a while:\n%: ./make.rc If the install was successful, we can now persist the installation and do some cleanup:\n%: unmount /sys/lib/go/amd64-1.14.7 %: dircp /tmp/go /sys/lib/go/amd64-1.14.7 %: cp /sys/lib/go/amd64-1.14.7/bin/* /amd64/bin %: unmount /tmp Next you will want to add a line like the following to your profile so that you can run executables in your GOPATH.\nbind -a $home/go/bin /bin This is the equivalent of export PATH=$PATH:/some/path on Unix. You will also want to turn on the Go modules flag in your $home/lib/profile:\nGO111MODULE=on Now you\u0026rsquo;ll need to get a ca cert for building most go modules:\n%: hget https://curl.haxx.se/ca/cacert.pem \u0026gt;/sys/lib/tls/ca.pem Next Steps\nI will continue to keep this post updated with relevant information to make sure it\u0026rsquo;s always up to date. If there is anything that you feel is missing, feel free to file an issue in Github. You may want to take a look at the Plan 9 Wiki which contains useful articles and links which should help you get more familiar with Plan 9. ","permalink":"https://dnjp.github.io/pages/plan9-on-qemu/","summary":"This guide assumes you are running a x86-64 Linux machine and that you have an up to date version of Qemu and curl installed. You may want to clone the repo containing useful scripts to help you get started.\nIn the shell examples below, any snippet starting with $: means that it should be executed on your Linux machine. Any snippet starting with %: should be executed in the Plan 9 VM.","title":"Plan9 on Qemu"},{"content":"Plan 9 is a distributed system that expands on the “everything is a file” metaphor by making almost all components available to the network. Need more CPU for a compute heavy workload? Spin up a CPU server and add it to your network. Need access to that script your friend wrote? Mount their namespace over 9P and just use the script. The Organization of Networks in Plan 9 by Dave Presotto and Phil Winterbottom explains this in greater detail and provides the following summary for how Plan 9 is used in practice:\n“At work, users tend to use their terminals like workstations, running interactive programs locally and reserving the CPU servers for data or compute intensive jobs such as compiling and computing chess endgames. At home or when connected over a slow network, users tend to do most work on the CPU server to minimize traffic on the slow links. The goal of the network organization is to provide the same environment to the user wherever resources are used.” The architecture of a Plan 9 system can range from running every component together on your local machine, to having each part distributed across a variety of machines in a much more elaborate configuration. As my first step in trying out some of these features, I’m going setup a basic Plan 9 configuration on a single VPS hosted in Linode. I am going to be doing this from my Macbook Air (M1, 2020) which brings along its own set of issues to contend with.\nCreating the VPS\nThe first step is to create a Linode account and navigate to the “Linodes” section on the left side panel and select “Create Linode”. Here are the settings I’d recommend for this initial test:\nImages: Alpine 3.14 (we’ll end up removing this image, so it doesn’t really matter which you select)\nRegion: Newark, NJ (pick whichever region is closest to you)\nLinode Plan: Shared CPU Nanode 1 GB ($5/month)\nLinode Label: 9front\nRoot Password: (we’re going to wipe away the Alpine image, so this doesn’t matter)\nAdd-ons: Private IP\nOnce these options are selected, click “Create Linode” on the right to spin up your VPS. Once it’s up, select your new machine and click “Power Off” towards the top because we’re about to create some new disks and setup configurations for installing and running Plan 9.\nWe will be creating 2 disks for this installation - one which will contain the contents of the Plan 9 ISO (we’ll be using 9front) and the other will be our primary disk we will be booting into after the installation.\nFirst, delete any disks that Linode created by clicking the “…” button followed by “Delete” next to each disk. Then, click “Add a Disk” and create the two disks in this order:\nInstaller:\nLabel: installer\nFilesystem: raw\nSize: 650 MB\nBoot:\nLabel: boot\nFilesystem: raw\nSize: 24950 MB (the remaining space left)\nNow we’ll create 2 configurations - one to boot the install media and the other we’ll use to boot Plan 9 after the install. Select “Configurations”, click “Add Configuration”, and create these 2 configurations:\nInstaller:\nLabel: installer\nVirtual Machine:\nVM Mode: Full virtualization Boot Settings:\nSelect a Kernel: Direct Disk\nRun Level: Run Default Level\nMemory Limit: Do not set any limits on memory usage\nBlock Device Assignment:\n/dev/sda: boot\n/dev/sdb: installer\n/dev/sdc: None\nRoot Device: /dev/sdb\nFilesystem/Boot Helpers: disable all enabled options\nBoot:\nLabel: boot\nVirtual Machine:\nVM Mode: Full virtualization Boot Settings:\nSelect a Kernel: Direct Disk\nRun Level: Run Default Level\nMemory Limit: Do not set any limits on memory usage\nBlock Device Assignment:\n/dev/sda: boot\n/dev/sdb: None\nRoot Device: /dev/sda\nFilesystem/Boot Helpers: disable all enabled options\nWith all of this configuration out of the way, now we will actually install Plan 9. Click the “…” icon for your machine and select “Rescue”. This will boot us into a mode where we can unpack the ISO and setup our “installer” disk. Once the machine has booted, click “Launch LISH Console” which will pull up a terminal in your web browser.\nWhile this is coming online, copy the link to the 9front release you want to install. In the Linode LISH console, run the following command to write the ISO to the “installer” disk:\nwget http://9front.org/iso/9front-8392.16c5ead832f2.amd64.iso.gz -q -O - | funzip | dd of=/dev/sda When this has completed, close the LISH Console window, and click the “Boot” button for the “installer” disk. Once the machine has finished restarting, click “Launch LISH Console” again and click the “Glish” tab in the window that opens. If all goes well, you should be in the Plan 9 terminal which will have default options for booting into the graphical environment. Hit Enter for each of these options to select the defaults. When rio launches, it will ask you to select the mouseport where you should enter “ps2intellimouse”. In the terminal window that will open, enter inst/start to begin the installation. At this point, you can follow the FQA to complete installing Plan 9 with a few exceptions.\nIn the partdist step, you will need to delete all of the partitions on /dev/sdC0 with d until the disk simply shows empty. Enter w and then q to write the change which will restart the partdist step with the empty partion selected. You can simply enter w and then q again to write the default Plan 9 partitions. During the mountdist step, be sure to select /dev/sdC1/data for the distribution disk.\nWhen the installation is completed and the installer restarts the machine, close out of the LISH console. Now, click “Boot” for the “boot” disk to boot up Plan 9 normally. We’ll again select the default options in the terminal which will then launch rio on your new Plan 9 VPS.\nSet up CPU Server\nObviously, interacting with Plan 9 through the LISH Console is not the most pleasant experience. We will be configuring Plan 9 to run as a standalone CPU server which we will connect to with Drawterm.\nThe first step is to modify the default boot settings for Plan 9:\n% 9fs 9fat % cd /n/9fat % cp plan9.ini plan9.ini.bak # keep a backup % sam plan9.ini This will open up the sam editor so we can edit the ini file. Right click in the bottom section of the editor and select “plan9.ini” and then right click again in the bottom section to open the file.\nRight click on the desktop, click “New”, and right click drag the size of the window you want to create. In that window, we will get some networking information that we will need to modify the plan9.ini file:\n% ip/ipconfig % cat /net/ndb Back in sam, add the following to the end of the plan9.ini file\nnobootprompt=local!/dev/sdC0/fs -m \u0026lt;mem\u0026gt; -A -a tcp!*!564 user=glenda auth=\u0026lt;your ip address\u0026gt; cpu=\u0026lt;your ip address\u0026gt; authdom=\u0026lt;choose name\u0026gt; service=cpu Once these changes have been made, click on the top part of the editor and enter “w” and then “q” to save the file and quit sam. Now we will setup the auth server:\n% auth/wrkey # authid: glenda # authdom: \u0026lt;same as plan9.ini\u0026gt; # secstore key: \u0026lt;enter password\u0026gt; # password: \u0026lt;enter same password\u0026gt; % auth/keyfs % auth/changeuser glenda # Password: \u0026lt;same as used above\u0026gt; # POP secret: doesn\u0026#39;t matter # Expiration Date: never # Post id: glenda # User\u0026#39;s full name: \u0026lt;whatever you want\u0026gt; % auth/enable glenda Now we’ll configure the network database:\n% cd /lib/ndb % sam ./local Towards the end of the file there will be a line that starts with sys=somehost ether=\u0026hellip;. Change this line to the following:\nsys=\u0026lt;keep value\u0026gt; ether=\u0026lt;keep value\u0026gt; authdom=\u0026lt;same as plan9.ini\u0026gt; auth=\u0026lt;your ip address\u0026gt; ip=\u0026lt;your ip\u0026gt; Below the sys line, add the following settings:\nipnet=\u0026lt;give a name\u0026gt; ip=\u0026lt;your ip, replace last number with 0\u0026gt; ipmask=\u0026lt;same as /net/ndb\u0026gt; ipgw=\u0026lt;same as /net/ndb\u0026gt; auth=\u0026lt;your ip\u0026gt; authdom=\u0026lt;same as plan9.ini\u0026gt; fs=\u0026lt;your ip\u0026gt; cpu=\u0026lt;your ip\u0026gt; dns=\u0026lt;same as /net/ndb\u0026gt; Save the file and quit sam. Now we will modify your users profile so that when we launch drawterm that we’ll have rio launch automatically:\n$ cd $home $ sam lib/profile Find the cpu case in the service switch statement. Directly under the fn cpu%\u0026hellip; line, add a new line to start rio:\nfn cpu%{ $* } rio -i riostart -s Save the file, quit sam, and sync the disk:\n% echo sync \u0026gt;\u0026gt; /srv/hjfs.cmd % fshalt -r This will restart the machine, but make sure it returns to “Running” in Linode. Click “Launch LISH Console” and select the Glish tab after the machine restarts, accept the defaults in the terminal, and that should get you to a prompt starting with cirno#. We’re now ready to set up Drawterm. Drawterm\nTo get started, clone the drawterm git repo locally and change to its directory. Follow the README to install for your platform. For MacOS, this means:\n$ CONF=osx-cocoa make $ cp drawterm gui-cocoa/drawterm.app/ $ cp -r gui-cocoa/drawterm.app /Applications/ I’ve made some small changes to the MacOS app to boot my settings by default. You can check them out here. For Linux, once the build has completed, copy the drawterm binary to /usr/local/bin.\nNow, copy the IP address for your VPS in Linode and launch drawterm:\n$ drawterm -u glenda -a \u0026lt;VPS IP\u0026gt; -h \u0026lt;VPS IP\u0026gt; If all goes well, a graphical window should launch and prompt you to enter the password for the glenda user that you set earlier. Enter the password, and you should now have rio running through drawterm on your local machine. A quick note: your local file system is available in drawterm at /mnt/term which enables you to use Plan 9 to work with files on your Unix machine. ","permalink":"https://dnjp.github.io/pages/setup-plan-9-vps-and-drawterm-on-linode/","summary":"Plan 9 is a distributed system that expands on the “everything is a file” metaphor by making almost all components available to the network. Need more CPU for a compute heavy workload? Spin up a CPU server and add it to your network. Need access to that script your friend wrote? Mount their namespace over 9P and just use the script. The Organization of Networks in Plan 9 by Dave Presotto and Phil Winterbottom explains this in greater detail and provides the following summary for how Plan 9 is used in practice:","title":"Setup Plan 9 VPS and Drawterm on Linode"},{"content":"I’ve tried a lot of different tools looking for those that are reliable, a joy to use, and visually appealing when applicable. These are the tools I’ve arrived at and currently use:\nSublime Text\nAn elegant and efficient text editor that balances productivity and configurability. Sublime Merge\nA desktop Git client that pairs well with Sublime Text. While nothing beats the power of Git on the command line, the majority of the time what I need is simple. Diffing, composing commits, handling merge conflicts, and branch management make up 90% of the features I regularly use in Git and having a GUI makes each of these tasks significantly easier. iTerm2\nA modern terminal that is pleasant to use. Roam Research\nRoam is a powerful knowledge management tool and it is where I dump my notes, thoughts, and ideas all throughout my day. The tagging features of Roam enable me to quickly search, find, and pull together notes from different contexts into a cohesive structure. TablePlus\nThe best database manager I’ve used on MacOS that supports both SQL and a variety of NoSQL databases. Arq Backup\nDependably backs up my MacOS machine to cloud storage. Alfred\nThe rest of the features I wish were built right into MacOS - hotkeys, text snippets, scripting, all the MacOS automation your heart could desire. Karabiner-Elements\nKeyboard customizer for MacOS that most importantly allows me to remap CapsLock to both Escape and Control. Software I used to use\nAcme\nRob Pike’s text editor from Plan 9. Nyne\nNyne is a configuration tool and event processing library that I wrote for Acme/Edwood. You can think of it as the .vimrc for Acme. nvi\nnvi is the text editor originally distributed with the Fourth Berkeley Software Distribution (4BSD). Vim\nVi IMproved - The most widely used \u0026ldquo;standard\u0026rdquo; vi implementation Emacs\nThe Emacs Lisp interpreter that happens to also be a text editor Linux\nThe target platform for most of the software I write. When using it on the Desktop, I got tired of constant display and audio issues which, of course, work almost flawlessly on MacOS. ","permalink":"https://dnjp.github.io/pages/tools-i-use/","summary":"I’ve tried a lot of different tools looking for those that are reliable, a joy to use, and visually appealing when applicable. These are the tools I’ve arrived at and currently use:\nSublime Text\nAn elegant and efficient text editor that balances productivity and configurability. Sublime Merge\nA desktop Git client that pairs well with Sublime Text. While nothing beats the power of Git on the command line, the majority of the time what I need is simple.","title":"Tools I Use"}]